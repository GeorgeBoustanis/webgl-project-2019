<!DOCTYPE HTML>
<html>
<head>
<script src="webgl-debug.js"></script>
<script src="gl-matrix-min.js"></script>
<script id="vShader" type="x-shader/x-vertex">
// Ο παρακάτω κώδικας δεν είναι Javascript αλλά GLSL (GL Shader Language)
	attribute vec4 aVertexPosition; // attribute: παράμετρος εισόδου του shader
	attribute vec4 aVertexColor;
	
	uniform mat4 uTransformMatrix; 
	
	// BHMA 0.1 Ένα νέο έξτρα uniform που θα υποδεχθεί τον πίνακα μετασχηματισμού προοπτικής/κάμερας (Perspective/View)
	uniform mat4 uPerspectiveViewMatrix;	
	
	varying vec4 vColor; // varying: μεταβλητή εξόδου προς το fragment shader
	
	void main() {
		// ΒΗΜΑ 0.2 Το νέο uniform uPerspectiveViewMatrix συμμετέχει στον πολλαπλασιασμό για τη θέση της κάθε κορυφής 
		// (μετά από πιθανές μετακινήσεις κλπ. που περιέχονται στο uniform uTransformMatrix)
		gl_Position = uPerspectiveViewMatrix * uTransformMatrix * aVertexPosition; 
		
		vColor = aVertexColor;  // Χρώμα κάθε κορυφής (vertex) 
	} 
</script>
<script id="fShader" type="x-shader/x-fragment">
	precision mediump float; 
	varying vec4 vColor; 
	void main() {
		gl_FragColor = vColor;
	}
</script>
<script>
var gl; 
var canvas; 
var shaderProgram; 
var vertexBuffer; 
var colorBuffer; 
var vertexPositionAttributePointer; // Η διεύθυνση του attribute aVertexPosition
var vertexColorAttributePointer; // Η διεύθυνση του attribute aVertexColor
var indexBuffer;
var start = 0;
var perspDistHigh = 10; //αν εκτελεστει η redraw πανω απο μια φορες τοτε το perspDist θα γινει cameraDistance * 10
var perspDistLow = 0.01;

// ΒΗΜΑ.1. Προσθέστε τρεις νέους buffers: (α) για τις κορυφές του πατώματος, (β) για τα χρώματα των κορυφών του πατώματος και (γ) για τους indices των κορυφών του πατώματος
// Προτεινόμενα ονόματα: floorVBuffer, floorCBuffer, floorIBuffer

var totalAngle=0; 

var transformUniformPointer;

// BHMA 0.3. Έχει δηλωθεί μία νέα global μεταβλητή για την αποθήκευση της διεύθυνσης του νέου uniform 
var perspectiveViewUniformPointer;

// ΒΗΜΑ.4. ΠΡΟΣΘΕΣΤΕ ΕΔΩ ΤΗ ΔΗΛΩΣΗ ΜΙΑΣ GLOBAL ΜΕΤΑΒΛΗΤΗΣ totalZ ΓΙΑ ΤΟ ΣΥΝΟΛΙΚΟ ΥΨΟΣ z ΤΗΣ ΚΑΜΕΡΑΣ ΚΑΙ ΑΡΧΙΚΟΠΟΙΗΣΤΕ ΤΗ ΣΕ 0.25
var totalZ = 0.25;

var requestId=0; 
  
function createGLContext(canvas) {
	var context = null;

	context = canvas.getContext("webgl");  
	if (!context)
		context = canvas.getContext("experimental-webgl"); 
	if (context) {
		context.viewportWidth = canvas.width; 
		context.viewportHeight = canvas.height; 
	} 
	else {
		alert("Failed to create WebGL context!");
	}
	return context;
}

function loadShader(type, shaderSource) {
	var shader = gl.createShader(type); 
	gl.shaderSource(shader, shaderSource); 
	gl.compileShader(shader); 

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { 
		alert("Error compiling shader" + gl.getShaderInfoLog(shader)); 
		gl.deleteShader(shader);  
		return null;
	}
	return shader;  
}

function setupShaders() {
	var vertexShaderSource = document.getElementById("vShader").textContent; 
	
	var fragmentShaderSource = document.getElementById("fShader").textContent; 
	
	var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource); 
	var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource); 

	shaderProgram = gl.createProgram(); 
	gl.attachShader(shaderProgram, vertexShader); 
	gl.attachShader(shaderProgram, fragmentShader); 
	gl.linkProgram(shaderProgram); 

	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		alert("Failed to setup shaders");
	}

	gl.useProgram(shaderProgram); 

	vertexPositionAttributePointer = gl.getAttribLocation(shaderProgram, "aVertexPosition"); 

	gl.enableVertexAttribArray(vertexPositionAttributePointer); 
	
	vertexColorAttributePointer = gl.getAttribLocation(shaderProgram, "aVertexColor"); 
	gl.enableVertexAttribArray(vertexColorAttributePointer);
	
	transformUniformPointer = gl.getUniformLocation(shaderProgram, "uTransformMatrix"); 
	
	// BHMA.0.4 Αποθηκεύεται στο σχετικό pointer η διεύθυνση του νέου uniform uPerspectiveViewMatrix
	perspectiveViewUniformPointer = gl.getUniformLocation(shaderProgram, "uPerspectiveViewMatrix");
}

function setupBuffers() {

// Έναρξη δημιουργίας και ενημέρωσης ("ταΐσματος") του buffer των κορυφών της κεντρικής πυραμίδας (οι άλλες προκύπτουν με μετασχηματισμούς μετακίνησης)

	//οι κορυφες των τριγωνων ΓΙΑ ΤΟΝ ΚΥΒΟ ΠΛΕΟΝ	
	
	vertexBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); 
	var triangleVertices = [
							-0.5, 0.5, 0.5, 1.0,  //Α
							-0.5, -0.5, 0.5, 1.0, //Β
							0.5, -0.5, 0.5, 1.0,  //Γ
							0.5, 0.5, 0.5, 1.0,   //Δ
							-0.5, 0.5, -0.5, 1.0, //Ε
							0.5, 0.5, -0.5, 1.0,  //Ζ
							0.5, -0.5, -0.5, 1.0, //Η
							-0.5, -0.5, -0.5, 1.0 //Θ
							];
	
	//8 διαφορετικες κορυφες για σχεδιαση τριγωνων που θα φτιαξουν εναν 3d κυβο
	
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertices),	gl.STATIC_DRAW);
	vertexBuffer.itemSize = 4; 
	vertexBuffer.numberOfItems = 8; 
// Τέλος δημιουργίας/ενημέρωσης buffer κορυφών κεντρικής πυραμίδας

// Έναρξη δημιουργίας και ενημέρωσης ("ταΐσματος") του buffer των ΧΡΩΜΑΤΩΝ των κορυφών της κεντρικής πυραμίδας
	colorBuffer=gl.createBuffer(); 
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
	var colorVertices = [0.329, 0.537, 0.713, 1.0,
						0.329, 0.537, 0.713, 1.0,
						0.180, 0.266, 0.862, 1.0,
						0.180, 0.635, 0.862, 1.0,
						0.082, 0.258, 0.698, 1.0,
						0.082, 0.258, 0.698, 1.0,
						0.235, 0.105, 0.772, 1.0,
						0.235, 0.105, 0.772, 1.0
						];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorVertices),	gl.STATIC_DRAW);
	colorBuffer.itemSize=4;
	colorBuffer.numberOfItems=8;
// Τέλος δημιουργίας/ενημέρωσης buffer ΧΡΩΜΑΤΩΝ των κορυφών κεντρικής πυραμίδας

// Έναρξη δημιουργίας και ενημέρωσης ("ταΐσματος") του buffer των ΔΕΙΚΤΩΝ (indices) των κορυφών της κεντρικής πυραμίδας	
	indexBuffer = gl.createBuffer(); 
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 
	var indexMatrix = [
						0,1,2,
						0,3,2,
						0,4,5,
						0,3,5,
						3,5,6,
						6,3,2,
						4,5,7,
						7,5,6,
						0,4,7,
						7,0,1,
						1,2,7,
						7,2,6	
						];
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(indexMatrix),gl.STATIC_DRAW);   
	indexBuffer.itemSize=1; 
	indexBuffer.numberOfItems = 36;  
// Τέλος δημιουργίας/ενημέρωσης buffer ΔΕΙΚΤΩΝ (indices) των κορυφών κεντρικής πυραμίδας
		
// ΒΗΜΑ.2. Χρησιμοποιώντας τα 3 παραπάνω πακέτα εντολών σαν παράδειγμα, δημιουργείστε και "ταΐστε" εδώ τους 3 νέους buffers που αφορούν το πάτωμα
// Θεωρείστε και τοποθετείστε το πάτωμα παράλληλο στο επίπεδο xy και στο κέντρο του, με διαστάσεις 2x2 και με z=-0.2
}



function redraw() {
	start++; //αν εκτελεστει η redraw αυξανεται ο μετρητης start
	
	
	var cameraView = 90*Math.PI/180;
	var cameraDistance = 2;
	var tokens;
	
	var fx = fy = fz = 1;
	
		
	if(start > 1){
		tokens = (document.querySelector('input[name="position"]:checked').value).split("-");
		if(tokens[0] == "Left")  fx = -1;
		if(tokens[1] == "Bottom")  fy = -1;
		if(tokens[2] == "Back")	fz = -1;
		cameraDistance = parseFloat(document.getElementById("cameraDistance").value);
		perspDistHigh = cameraDistance * 10;
		perspDistLow = 0.001;
		cameraView = parseFloat(document.getElementById("cameraView").value) * Math.PI/180.0;
	}
	
	//πινακας μετ/μου καμερας-view
	var vMatrix = mat4.create();
	//"γεμισμα" του πινακα μετ/σμου καμερας-view
	mat4.lookAt(vMatrix,[fx*cameraDistance,fy*cameraDistance,fz*cameraDistance],[0,0,0],[0,1,0]);
	
	//πινακας μετ/μου προοπτικης-perspective
	var pMatrix = mat4.create();
	//"γεμισμα" πινακα μετ/σμου προοπτικης-perspective
	mat4.perspective(pMatrix,cameraView,1,perspDistLow,perspDistHigh);
	
	//γινομενο perspective * view	
	var pvMatrix = mat4.create();
	
	//εκτελειται ο πολ/σμος πινακων καμερας και προοπτικης
	//το γινομενο καταληγει στον pvMatrix
	mat4.multiply(pvMatrix,pMatrix,vMatrix);
	
	//τροφοδοτω το uniform καμερας/προοπτικης μεσω pointer, με τον πινακα γινομενου "καμερα επι προοπτικη"
	gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, new Float32Array(pvMatrix));
		
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	//τροφοδοτω το attribute aVertexPosition (vertex shader) μεσω pointer
	//με τα περιεχομενα του buffer κορυφων (vertexBuffer)
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	//τροφοδοτω το attribute aVertexColor (vertex shader) μεσω pointer
	//με τα περιεχομενα του buffer χρωματων (colorBuffer)
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
	gl.vertexAttribPointer(vertexColorAttributePointer, colorBuffer.itemSize, gl.FLOAT, false, 0, 0); 
	
	//"ενεργοποιηση" του buffer με τους δεικτες κορυφων (indexBuffer)
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer); 

	//προς το παρον ο πινακας μετ/σμου (uniform) που υπαρχει στον vertex shader
	//θα γεμιστει με τον μοναδιαιο πινακα ετσι ωστε να μην εκτελεστει στον κυβο καποιος
	//επιπλεον μετασχηματισμος περαν του μετ/μου καμερας/προοπτικης
	var temp=mat4.create();
		
	gl.uniformMatrix4fv(transformUniformPointer, false, new Float32Array(temp)); 
	gl.drawElements(gl.TRIANGLES,indexBuffer.numberOfItems,gl.UNSIGNED_SHORT, 0);
}

function startup() {
	canvas = document.getElementById("myGLCanvas"); 
	var minDimension=Math.min(window.innerWidth,window.innerHeight); 
	canvas.width=0.9*minDimension; 
	canvas.height=0.9*minDimension; 
	gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas)); 
	setupShaders(); 
	setupBuffers(); 
	gl.clearColor(0.5, 0.6, 0.42, 1.0); 
	
	gl.enable(gl.DEPTH_TEST); 
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 	
	redraw(); 
}

</script>

</head>

<body onload="startup()">
<canvas id="myGLCanvas" >
</canvas>

<br>
camera view (degrees):<input type="text" id="cameraView" value="90">
<br>
camera distance:<input type="text" id="cameraDistance" value="2">
<br><br>
<div id="radioButtons">
	<input type="radio" name="position" value="Right-Top-Front" checked="checked">Right Top Front<br>
	<input type="radio" name="position" value="Right-Bottom-Back">Right Bottom Back<br>
	<input type="radio" name="position" value="Right-Bottom-Front">Right Bottom Front<br>
	<input type="radio" name="position" value="Right-Top-Back">Right Top Back<br>
	<input type="radio" name="position" value="Left-Bottom-Back">Left Bottom Back<br>
	<input type="radio" name="position" value="Left-Bottom-Front">Left Bottom Front<br>
	<input type="radio" name="position" value="Left-Top-Back">Left Top Back<br>
	<input type="radio" name="position" value="Left-Top-Front">Left Top Front<br>
</div>
<button onClick="redraw()">Redraw scene</button>
<!-- ΒΗΜΑ.5. ΠΡΟΣΘΕΣΤΕ ΕΔΩ ΕΝΑ ΤΕΧΤ ΒΟΧ ΓΙΑ ΤΟ ΒΗΜΑ ΤΟΥ ΥΨΟΥΣ ΤΗΣ ΚΑΜΕΡΑΣ (ΠΡΟΤΕΙΝΟΜΕΝΟ VALUE 0.01)--->
</body>
</html>
<!--
ΧΡΗΣΗ ΠΟΛΛΩΝ BUFFERS ΓΙΑ ΣΧΕΔΙΑΣΗ 
Στόχος αυτής της άσκησης είναι η σχεδίαση ενός "πατώματος" κάτω από τις πυραμίδες (παράλληλο στο επίπεδο xy, με διαστάσεις 2x2 και με z=-0.2)... 

ΤΟΠΟΘΕΤΗΣΗ "ΚΑΜΕΡΑΣ"
... και προβολή της σκηνής από διαφορετικά σημεία παρατήρησης μέσω ενός αντίστοιχου μετασχηματισμού για τη θέση της κάμερας

ΑΚΟΛΟΥΘΕΙΣΤΕ ΤΑ ΒΗΜΑ.ΤΑ ΠΟΥ ΕΜΦΑΝΙΖΟΝΤΑΙ ΣΑΝ ΑΡΙΘΜΗΜΕΝΑ ΣΧΟΛΙΑ ΣΤΟΝ ΚΩΔΙΚΑ, ΣΥΜΠΛΗΡΩΝΟΝΤΑΣ ΤΙΣ ΑΝΤΙΣΤΟΙΧΕΣ ΕΝΤΟΛΕΣ ΜΕ ΤΗ ΣΕΙΡΑ ΤΗΣ ΑΡΙΘΜΗΣΗΣ
-->
